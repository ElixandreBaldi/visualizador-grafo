package visualizadorgrafo;

import java.awt.Color;
import java.awt.Font;
import java.awt.Graphics;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.nio.charset.Charset;
import javax.swing.JFileChooser;
import javax.swing.JOptionPane;
import javax.swing.SwingUtilities;
import static java.lang.Character.getNumericValue;

/**
 * @author Elixandre M. Baldi <https://github.com/ElixandreBaldi>
 * @author Luiz Guilherme F. Rosa <https://github.com/luizguilhermefr>
 */
public class VisualizadorGrafo extends javax.swing.JFrame {

    /**
     * Creates new form VisualizadorGrafo
     */
    public VisualizadorGrafo() {
        initComponents();
        graphPanel.addMouseListener(new MouseListener() {

            @Override
            public void mouseClicked(MouseEvent e) {
                int x = e.getX();
                int y = e.getY();
                System.out.println(x + "," + y);
                if (graphPanel.isEnabled()) {
                    insertVertex(x, y);
                }
            }

            @Override
            public void mousePressed(MouseEvent e) {
                //
            }

            @Override
            public void mouseReleased(MouseEvent e) {
                //
            }

            @Override
            public void mouseEntered(MouseEvent e) {
                //
            }

            @Override
            public void mouseExited(MouseEvent e) {
                //
            }
        });
    }
    
    /**
     * Paint stuff on the screen.
     * @param g The graphic where to paint.
     */
    @Override
    public void paint(Graphics g) {
        super.paint(g);
        if (redraw) {
            g = graphPanel.getGraphics();
            for (int i = 0; i < nVertex; i++) { // draw edges
                for (int j = i; j < nVertex; j++) {
                    if (adjacency[i][j].getCost() != -1) {
                        int x1, x2, y1, y2;
                        x1 = vertex[i].getCoordX();
                        y1 = vertex[i].getCoordY();
                        x2 = vertex[j].getCoordX();
                        y2 = vertex[j].getCoordY();
                        g.drawLine(x1, y1, x2, y2);
                    }
                }
            }
            redraw = false;
        }
        goodman(false);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        selectOpenFile = new javax.swing.JFileChooser();
        selectSaveFile = new javax.swing.JFileChooser();
        lblEulerian = new javax.swing.JLabel();
        lblConnectedComponents = new javax.swing.JLabel();
        graphPanel = new javax.swing.JPanel();
        mainMenu = new javax.swing.JMenuBar();
        itemFile = new javax.swing.JMenu();
        subItemFileNew = new javax.swing.JMenuItem();
        subItemFileOpen = new javax.swing.JMenuItem();
        subItemFileSave = new javax.swing.JMenuItem();
        subItemFileExit = new javax.swing.JMenuItem();
        itemEdit = new javax.swing.JMenu();
        subItemEditInsertVertex = new javax.swing.JMenuItem();
        subItemEditInsertEdge = new javax.swing.JMenuItem();
        subItemEditRemoveVertex = new javax.swing.JMenuItem();
        subItemEditRemoveEdge = new javax.swing.JMenuItem();
        itemSearch = new javax.swing.JMenu();
        subItemSearchBreadthFirst = new javax.swing.JMenuItem();
        subItemSearchDepthFirst = new javax.swing.JMenuItem();
        itemAlgorithms = new javax.swing.JMenu();
        subItemAlgorithmsFleury = new javax.swing.JMenuItem();
        subItemAlgorithmsDijkstra = new javax.swing.JMenuItem();
        subItemAlgorithmsGoodman = new javax.swing.JMenuItem();

        selectOpenFile.setDialogTitle("Abrir");

        selectSaveFile.setDialogType(javax.swing.JFileChooser.SAVE_DIALOG);
        selectSaveFile.setApproveButtonText("Salvar");
        selectSaveFile.setApproveButtonToolTipText("Salvar");
        selectSaveFile.setDialogTitle("Salvar");

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Visualizador Grafo");
        setMinimumSize(new java.awt.Dimension(800, 600));
        setName("mainFrame"); // NOI18N

        lblEulerian.setText("Not eulerian");
        lblEulerian.setEnabled(false);
        lblEulerian.setFocusable(false);

        lblConnectedComponents.setText("Connected elements: 0");
        lblConnectedComponents.setEnabled(false);
        lblConnectedComponents.setFocusable(false);

        graphPanel.setBackground(new java.awt.Color(254, 254, 254));
        graphPanel.setBorder(javax.swing.BorderFactory.createLineBorder(new java.awt.Color(0, 0, 0), 0));
        graphPanel.setCursor(new java.awt.Cursor(java.awt.Cursor.HAND_CURSOR));
        graphPanel.setEnabled(false);

        javax.swing.GroupLayout graphPanelLayout = new javax.swing.GroupLayout(graphPanel);
        graphPanel.setLayout(graphPanelLayout);
        graphPanelLayout.setHorizontalGroup(
            graphPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 0, Short.MAX_VALUE)
        );
        graphPanelLayout.setVerticalGroup(
            graphPanelLayout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 532, Short.MAX_VALUE)
        );

        itemFile.setText("File");

        subItemFileNew.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_N, java.awt.event.InputEvent.CTRL_MASK));
        subItemFileNew.setText("New");
        subItemFileNew.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                subItemFileNewActionPerformed(evt);
            }
        });
        itemFile.add(subItemFileNew);

        subItemFileOpen.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_O, java.awt.event.InputEvent.CTRL_MASK));
        subItemFileOpen.setText("Open");
        subItemFileOpen.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                subItemFileOpenActionPerformed(evt);
            }
        });
        itemFile.add(subItemFileOpen);

        subItemFileSave.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_S, java.awt.event.InputEvent.CTRL_MASK));
        subItemFileSave.setText("Save");
        subItemFileSave.setEnabled(false);
        subItemFileSave.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                subItemFileSaveActionPerformed(evt);
            }
        });
        itemFile.add(subItemFileSave);

        subItemFileExit.setText("Exit");
        subItemFileExit.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                subItemFileExitActionPerformed(evt);
            }
        });
        itemFile.add(subItemFileExit);

        mainMenu.add(itemFile);

        itemEdit.setText("Edit");
        itemEdit.setEnabled(false);

        subItemEditInsertVertex.setText("Insert vertex");
        subItemEditInsertVertex.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                subItemEditInsertVertexActionPerformed(evt);
            }
        });
        itemEdit.add(subItemEditInsertVertex);

        subItemEditInsertEdge.setText("Insert edge");
        subItemEditInsertEdge.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                subItemEditInsertEdgeActionPerformed(evt);
            }
        });
        itemEdit.add(subItemEditInsertEdge);

        subItemEditRemoveVertex.setText("Remove vertex");
        subItemEditRemoveVertex.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                subItemEditRemoveVertexActionPerformed(evt);
            }
        });
        itemEdit.add(subItemEditRemoveVertex);

        subItemEditRemoveEdge.setText("Remove edge");
        subItemEditRemoveEdge.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                subItemEditRemoveEdgeActionPerformed(evt);
            }
        });
        itemEdit.add(subItemEditRemoveEdge);

        mainMenu.add(itemEdit);

        itemSearch.setText("Search");
        itemSearch.setEnabled(false);

        subItemSearchBreadthFirst.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_L, java.awt.event.InputEvent.CTRL_MASK));
        subItemSearchBreadthFirst.setText("Breadth First (BFS)");
        subItemSearchBreadthFirst.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                subItemSearchBreadthFirstActionPerformed(evt);
            }
        });
        itemSearch.add(subItemSearchBreadthFirst);

        subItemSearchDepthFirst.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_B, java.awt.event.InputEvent.CTRL_MASK));
        subItemSearchDepthFirst.setText("Depth First (DFS)");
        subItemSearchDepthFirst.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                subItemSearchDepthFirstActionPerformed(evt);
            }
        });
        itemSearch.add(subItemSearchDepthFirst);

        mainMenu.add(itemSearch);

        itemAlgorithms.setText("Algorithms");
        itemAlgorithms.setEnabled(false);

        subItemAlgorithmsFleury.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_F, java.awt.event.InputEvent.CTRL_MASK));
        subItemAlgorithmsFleury.setText("Eulerian Path (Fleury)");
        subItemAlgorithmsFleury.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                subItemAlgorithmsFleuryActionPerformed(evt);
            }
        });
        itemAlgorithms.add(subItemAlgorithmsFleury);

        subItemAlgorithmsDijkstra.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_D, java.awt.event.InputEvent.CTRL_MASK));
        subItemAlgorithmsDijkstra.setText("Minimum Cost (Dijkstra)");
        subItemAlgorithmsDijkstra.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                subItemAlgorithmsDijkstraActionPerformed(evt);
            }
        });
        itemAlgorithms.add(subItemAlgorithmsDijkstra);

        subItemAlgorithmsGoodman.setAccelerator(javax.swing.KeyStroke.getKeyStroke(java.awt.event.KeyEvent.VK_G, java.awt.event.InputEvent.CTRL_MASK));
        subItemAlgorithmsGoodman.setText("Goodman");
        subItemAlgorithmsGoodman.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                subItemAlgorithmsGoodmanActionPerformed(evt);
            }
        });
        itemAlgorithms.add(subItemAlgorithmsGoodman);

        mainMenu.add(itemAlgorithms);

        setJMenuBar(mainMenu);

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(graphPanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(lblEulerian)
                        .addGap(18, 18, 18)
                        .addComponent(lblConnectedComponents)
                        .addGap(0, 510, Short.MAX_VALUE)))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(graphPanel, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(lblEulerian)
                    .addComponent(lblConnectedComponents))
                .addContainerGap())
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    
    protected void redrawVertices() {
        for (int i = 0; i < nVertex; i++) {
            javax.swing.JLabel newLabel = new javax.swing.JLabel(vertex[i].getLabel(), javax.swing.JLabel.CENTER);
            newLabel.setBounds(vertex[i].getCoordX(), vertex[i].getCoordY(), newLabel.getPreferredSize().width, newLabel.getPreferredSize().height);
            newLabel.setForeground(Color.blue);
            newLabel.setToolTipText("<html>" + "<strong>id:</strong> " + i + "<br><strong>Rótulo:</strong> " + vertex[i].getLabel() + "<br><strong>X:</strong> " + vertex[i].getCoordX() + "<br><strong>Y:</strong> " + vertex[i].getCoordY() + "</html>");
            graphPanel.add(newLabel);
        }
        SwingUtilities.updateComponentTreeUI(this);
        redraw = true;
        repaint();
    }

    protected void drawEdgesLabels() {
        //limpa o painel do grafo e reinsere todos os elementos, em seguida chama repaint() para reinserir arestas
        graphPanel.removeAll();
        for (int i = 0; i < nVertex; i++) { //desenha arestas
            for (int j = i; j < nVertex; j++) {
                if (adjacency[i][j].getCost() != -1) {
                    javax.swing.JLabel lblRotulo = new javax.swing.JLabel(adjacency[i][j].getLabel(), javax.swing.JLabel.CENTER);
                    lblRotulo.setBounds((vertex[i].getCoordX() + vertex[j].getCoordX()) / 2, (vertex[i].getCoordY() + vertex[j].getCoordY()) / 2, lblRotulo.getPreferredSize().width, lblRotulo.getPreferredSize().height);
                    Font novaFonte = new Font(lblRotulo.getFont().getName(), lblRotulo.getFont().getStyle(), 10);
                    lblRotulo.setFont(novaFonte);
                    graphPanel.add(lblRotulo);
                }
            }
        }
        redrawVertices();
    }

    protected void reset() {
        // reinicia tudo para criar/abrir novos arquivos
        fileLocation = "";
        vertex = new Vertex[0];
        adjacency = new Edge[0][0];
        nVertex = 0;
        this.setTitle("Visualizador Grafo");
        graphPanel.removeAll();
        graphPanel.setEnabled(true);
        itemEdit.setEnabled(true);
        itemAlgorithms.setEnabled(true);
        subItemFileSave.setEnabled(true);
        redraw = true;
        repaint();
    }

    protected void analyzeLine(String text, boolean isAresta) throws Exception {
        if (!isAresta) { //vertice
            int i = 0, coordX = 0, coordY = 0;
            String rotulo = "";
            if (text.charAt(i) == '\'') { //inicio do rotulo
                i++;
                while (text.charAt(i) != '\'') {
                    rotulo += text.charAt(i);
                    i++;
                }
                i++; //fim do rotulo
            }
            if (text.charAt(i) == ' ') {
                i++; //espaço entre rotulo e x
            }
            while (text.charAt(i) != ' ') {
                coordX = (coordX * 10) + getNumericValue(text.charAt(i));
                i++;
            }
            i++; //espaço entre x e y
            while (text.charAt(i) != ';') {
                coordY = (coordY * 10) + getNumericValue(text.charAt(i));
                i++;
            }
            Vertex[] tmp = vertex; // copia o array vértice atual para um temporário
            nVertex++; // incrementa o número de vértices
            vertex = new Vertex[nVertex]; // recria o array de vértices vazio, com o novo tamanho
            System.arraycopy(tmp, 0, vertex, 0, tmp.length); // copia o array temporário para o novo
            Vertex novoVertice = new Vertex(coordX, coordY, rotulo); // cria um novo vértice
            vertex[nVertex - 1] = novoVertice; // insere o novo vértice na listagem
        } else {//aresta
            int i = 0, origem = 0, destino = 0, custo = 0;
            String rotulo = "";
            while (text.charAt(i) != ' ') {
                origem = (origem * 10) + getNumericValue(text.charAt(i));
                i++;
            }
            i++;
            while (text.charAt(i) != ' ') {
                destino = (destino * 10) + getNumericValue(text.charAt(i));
                i++;
            }
            i++;
            while (text.charAt(i) != ' ') {
                custo = (custo * 10) + getNumericValue(text.charAt(i));
                i++;
            }
            i++;
            if (text.charAt(i) == '\'') {
                i++;
                while (text.charAt(i) != '\'') {
                    rotulo += text.charAt(i);
                    i++;
                }
            }
            Edge a = new Edge(rotulo, custo);
            adjacency[origem - 1][destino - 1] = a;
            adjacency[destino - 1][origem - 1] = a;
        }
    }

    protected boolean isEulerian() {
        int cont;
        if (connectedComponents == 1) {
            for (int i = 0; i < nVertex; i++) {
                cont = 0;
                for (int j = 0; j < nVertex; j++) {
                    if (adjacency[i][j].getCost() != -1) {
                        cont++;
                    }
                }
                if (cont % 2 != 0) {
                    return false;
                }
            }
        } else {
            return false;
        }

        return true;
    }

    protected boolean isGraph(Edge[][] grafo, int n) {
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (grafo[i][j].getCost() != -1) {
                    return true;
                }
            }
        }
        return false;
    }

    protected void goodman(boolean withAlert) {
        Edge[][] adjacenciaGoodman = new Edge[nVertex][nVertex];

        for (int i = 0; i < nVertex; i++) {
            for (int j = 0; j < nVertex; j++) {
                adjacenciaGoodman[i][j] = new Edge(adjacency[i][j].getLabel(), adjacency[i][j].getCost());
            }
        }

        int nComponentesConexo = 0, visita = 0, primeiro = 0;
        boolean[] visitados = new boolean[nVertex];
        boolean flag = false;

        while (isGraph(adjacenciaGoodman, nVertex)) {
            Search B = new Search(nVertex, adjacenciaGoodman);
            for (int i = 0; i < nVertex; i++) {//escolhe qualquer um que não foi visitado                
                if (!visitados[i]) {
                    visita = i;
                    i = nVertex;
                }
                int conexos[] = B.profundidade(visita);
                primeiro = conexos[0];
                flag = true;
                for (int j = 0; j < nVertex; j++) {
                    if (conexos[j] != -1) {
                        visitados[conexos[j]] = true;
                    }
                }
                for (int j = 1; j < nVertex; j++) {
                    if (conexos[j] != -1) {
                        for (int w = 0; w < nVertex; w++) {
                            if (adjacenciaGoodman[primeiro][w].getCost() < adjacenciaGoodman[conexos[j]][w].getCost()) {
                                adjacenciaGoodman[primeiro][w] = new Edge(adjacenciaGoodman[conexos[j]][w].getLabel(), adjacenciaGoodman[conexos[j]][w].getCost());
                            }
                            adjacenciaGoodman[conexos[j]][w] = new Edge("NULL", -1);
                        }
                    }
                }
            }
            nComponentesConexo++;
            if (flag) {
                for (int i = 0; i < nVertex; i++) {
                    adjacenciaGoodman[primeiro][i] = new Edge("NULL", -1);
                }
            }
            flag = false;
        }
        for (int i = 0; i < nVertex; i++) {
            if (!visitados[i]) {
                nComponentesConexo++;
            }
        }
        connectedComponents = nComponentesConexo;
        lblConnectedComponents.setText("Componentes Conexos: " + nComponentesConexo);
        if (isEulerian()) {
            lblEulerian.setText("Euleriano");
        } else {
            lblEulerian.setText("Não euleriano");
        }
        if (withAlert) {
            JOptionPane.showMessageDialog(null, "Componentes Conexos: " + nComponentesConexo, "Algoritmo de Goodman", JOptionPane.INFORMATION_MESSAGE);
        }
    }

    protected String converteDadosParaArquivo() {
        String output = "";
        for (int i = 0; i < nVertex; i++) {
            output += "'" + vertex[i].getLabel() + "' " + vertex[i].getCoordX() + " " + vertex[i].getCoordY() + ";\n";
        }
        output += "\n";
        for (int i = 0; i < nVertex; i++) {
            for (int j = i; j < nVertex; j++) {
                if (adjacency[i][j].getCost() != -1) {
                    output += (i + 1) + " " + (j + 1) + " " + adjacency[i][j].getCost() + " '" + adjacency[i][j].getLabel() + "'\n";
                }
            }
        }
        return output;
    }

    protected void dijkstra(int origem) {
        Edge[][] adjacenciaDijkstra = new Edge[nVertex][nVertex];
        double dist[] = new double[nVertex]; // distancias entre a origem e cada indice deste vetor
        boolean fixo[] = new boolean[nVertex]; //informa se o indice deste vetor já foi visitado
        int faltam; //para movimentar o for
        String[] caminhos = new String[nVertex]; // concatena-se o caminhos mais curto entre o indice do vetor e a variavel origem     
        for (int i = 0; i < nVertex; i++) { //setar a tabela de adjacencia utilizada aqui
            for (int j = 0; j < nVertex; j++) {
                if (i == j) {
                    adjacenciaDijkstra[i][j] = new Edge("NULL", 0);
                    continue;
                }
                if (adjacency[i][j].getCost() != -1) {
                    adjacenciaDijkstra[i][j] = new Edge(adjacency[i][j].getLabel(), adjacency[i][j].getCost());
                } else {
                    adjacenciaDijkstra[i][j] = new Edge("NULL", bigM);
                }
            }
        }
        for (int i = 0; i < nVertex; i++) {//setar os valores
            fixo[i] = false;
            dist[i] = bigM;
            caminhos[i] = "";
        }
        dist[origem] = 0;

        for (faltam = nVertex; faltam > 0; faltam--) {
            int no = -1;
            for (int i = 0; i < nVertex; i++) {
                if (!fixo[i] && (no == -1 || dist[i] < dist[no])) {
                    no = i;
                }
            }

            fixo[no] = true;

            if (dist[no] >= bigM) {
                break;
            }

            for (int i = 0; i < nVertex; i++) {
                if (dist[i] > dist[no] + adjacenciaDijkstra[no][i].getCost()) {
                    dist[i] = dist[no] + adjacenciaDijkstra[no][i].getCost();
                    String vazio = "";
                    if (caminhos[no].equals(vazio)) {
                        caminhos[i] += vertex[no].getLabel() + "->";
                    } else {
                        caminhos[i] += caminhos[no] + vertex[no].getLabel() + "->";
                    }
                }
            }
        }
        String caminhosDijkstra = "Origem: " + vertex[origem].getLabel() + "\n\n\n";
        for (int i = 0; i < nVertex; i++) {
            caminhos[i] += vertex[i].getLabel();
            if (i != origem) {
                if (dist[i] >= Double.POSITIVE_INFINITY) {
                    caminhosDijkstra += "Distancia entre " + vertex[origem].getLabel() + " e " + vertex[i].getLabel() + " = Nao existe\n";
                } else {
                    caminhosDijkstra += "Distancia entre " + vertex[origem].getLabel() + " e " + vertex[i].getLabel() + " = " + dist[i] + "\nCaminho com menor custo: " + caminhos[i] + "\n";
                }
                if (i < nVertex - 1) {
                    caminhosDijkstra += "\n";
                }
            }
        }
        JOptionPane.showMessageDialog(null, caminhosDijkstra, "Algoritmo Dijkstra", JOptionPane.INFORMATION_MESSAGE);
    }

    protected int countEdges() {
        int cont = 0;

        for (int i = 0; i < nVertex; i++) {
            for (int j = i; j < nVertex; j++) {
                if (adjacency[i][j].getCost() != -1) {
                    cont++;
                }
            }
        }
        return cont;
    }

    protected void eulerianPath(Edge[][] adjacenciaEuleriano) {
        int noInformado;
        String xString = JOptionPane.showInputDialog(graphPanel,
                "Informe o nó de início", null);
        try {
            noInformado = Integer.parseInt(xString);
        } catch (NumberFormatException e) {
            JOptionPane.showMessageDialog(null, "Invalid value.", "Error", JOptionPane.ERROR_MESSAGE);
            System.err.println(e);
            return;
        }

        int qtdArestas = countEdges();
        int listaArestas[][] = new int[qtdArestas][2];
        int iVisitas = 0;
        for (int i = 0; i < qtdArestas; i++) {
            listaArestas[i][0] = -1;
            listaArestas[i][1] = -1;
        }

        Search cicloEuleriano = new Search(nVertex, adjacenciaEuleriano, qtdArestas);
        listaArestas = cicloEuleriano.cicloEuleriano(noInformado);

        String cicloEulerianoString = "";
        for (int i = 0; i < qtdArestas; i++) {
            cicloEulerianoString += listaArestas[i][0] + "->";
        }

        cicloEulerianoString += listaArestas[qtdArestas - 1][1];

        JOptionPane.showMessageDialog(null, cicloEulerianoString, "Ciclo Euleriano", JOptionPane.INFORMATION_MESSAGE);

    }

    protected void depthFirstSearch(int inicio) {
        Search B = new Search(nVertex, adjacency);
        int[] vetor = B.profundidade(inicio);
        String msg = "";
        for (int i = 0; i < nVertex; i++) {
            if (vetor[i] != -1) {
                if (i > 0) {
                    msg += "->";
                }
                msg += vertex[vetor[i]].getLabel();
            }
        }
        JOptionPane.showMessageDialog(null, msg, "Busca em Profundidade", JOptionPane.INFORMATION_MESSAGE);
    }

    protected void breadthFirstSearch(int inicio) {
        Search b = new Search(nVertex, adjacency);
        int[] vetor = b.largura(inicio);
        String msg = "";
        for (int i = 0; i < nVertex; i++) {
            if (vetor[i] != -1) {
                if (i > 0) {
                    msg += "->";
                }
                msg += vertex[vetor[i]].getLabel();
            }
        }
        JOptionPane.showMessageDialog(null, msg, "Busca em Largura", JOptionPane.INFORMATION_MESSAGE);
    }

    protected void openFile() {
        String conteudo = "", line;
        int returnVal = selectOpenFile.showOpenDialog(this);
        if (returnVal == JFileChooser.APPROVE_OPTION) {
            reset();
            Charset inputCharset = Charset.forName("ISO-8859-1");
            try {
                File file = selectOpenFile.getSelectedFile();
                BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(file), inputCharset));
                fileLocation = file.getAbsolutePath();
                this.setTitle("Visualizador Grafo - " + file.getName());
                boolean isAresta = false;
                while ((line = reader.readLine()) != null) {
                    if (line.length() > 2) {
                        if (line.charAt(0) == '/') {
                            if (line.charAt(1) == '/') {
                                continue;
                            }
                        }
                    }
                    if (line.isEmpty()) {
                        isAresta = true;
                        adjacency = new Edge[nVertex][nVertex];
                        for (int i = 0; i < nVertex; i++) {
                            for (int j = 0; j < nVertex; j++) {
                                adjacency[i][j] = new Edge("NULL", -1);
                            }
                        }
                        continue;
                    }
                    analyzeLine(line, isAresta);
                }
                reader.close();
                System.out.println("Leitura bem-sucedida.");
            } catch (Exception e) {
                JOptionPane.showMessageDialog(null, "Error ao carregar arquivo.", "Error", JOptionPane.ERROR_MESSAGE);
                System.err.println(e);
            }
            drawEdgesLabels();
            redraw = true;
            repaint();
        }
    }

    protected void saveFile() {
        int returnVal = selectSaveFile.showSaveDialog(this);
        if (returnVal == JFileChooser.APPROVE_OPTION) {
            try {
                File file = selectSaveFile.getSelectedFile();
                FileWriter fw = new FileWriter(file + ".grafo");
                fw.write(converteDadosParaArquivo());
                fw.flush();
                fileLocation = file.getAbsolutePath();
                this.setTitle("Visualizador Grafo - " + file.getName());
            } catch (IOException e) {
                JOptionPane.showMessageDialog(null, "Error ao salvar arquivo.", "Error", JOptionPane.ERROR_MESSAGE);
                System.err.println(e);
            }
        }
    }

    protected void insertVertex(int x, int y) {
        String rotulo = JOptionPane.showInputDialog(graphPanel,
                "Rótulo", null);
        if (rotulo == null) {
            return;
        }
        nVertex++; // incrementa o número de vértices
        Edge[][] tmp = adjacency;
        adjacency = new Edge[nVertex][nVertex];
        for (int i = 0; i < nVertex - 1; i++) {
            System.arraycopy(tmp[i], 0, adjacency[i], 0, nVertex - 1);
        }
        for (int i = 0; i < nVertex; i++) {
            adjacency[i][nVertex - 1] = new Edge("NULL", -1);
        }
        for (int i = 0; i < nVertex; i++) {
            adjacency[nVertex - 1][i] = new Edge("NULL", -1);
        }
        Vertex[] tmp2 = vertex; // copia o array vértice atual para um temporário
        vertex = new Vertex[nVertex]; // recria o array de vértices vazio, com o novo tamanho
        System.arraycopy(tmp2, 0, vertex, 0, tmp2.length); // copia o array temporário para o novo
        Vertex novoVertice = new Vertex(x, y, rotulo); // cria um novo vértice
        vertex[nVertex - 1] = novoVertice; // insere o novo vértice na listagem
        drawEdgesLabels();
    }

    protected void removeVertex(int id) {
        nVertex--;
        Vertex[] tmp = vertex; // copia o array vértice atual para um temporário
        vertex = new Vertex[nVertex];
        for (int i = 0; i < id; i++) {
            vertex[i] = tmp[i]; //copia a primeira parte do array, antes do elemento excluido
        }
        if (id < nVertex) {
            for (int i = id + 1; i < nVertex + 1; i++) {
                vertex[i - 1] = tmp[i]; //copia a segunda parte do array, depois do elemento excluido
            }        //Apaga arestas do nodo excluído
        }
        Edge[][] tmp2 = adjacency;
        adjacency = new Edge[nVertex][nVertex];
        for (int i = 0; i < id; i++) // primeiro quadrante
        {
            for (int j = 0; j < id; j++) {
                adjacency[i][j] = tmp2[i][j];
            }
        }
        for (int i = id + 1; i < nVertex + 1; i++) // segundo quadrante
        {
            for (int j = 0; j < id; j++) {
                adjacency[i - 1][j] = tmp2[i][j];
            }
        }
        for (int i = 0; i < id; i++) // terceiro quadrante
        {
            for (int j = id + 1; j < nVertex + 1; j++) {
                adjacency[i][j - 1] = tmp2[i][j];
            }
        }
        for (int i = id + 1; i < nVertex + 1; i++) // quarto quadrante
        {
            for (int j = id + 1; j < nVertex + 1; j++) {
                adjacency[i - 1][j - 1] = tmp2[i][j];
            }
        }
        drawEdgesLabels();
    }

    protected void insertEdge(int origem, int destino) {
        int custo;
        String rotulo = JOptionPane.showInputDialog(graphPanel,
                "Rótulo", null);
        String custoString = JOptionPane.showInputDialog(graphPanel,
                "Custo", null);
        try {
            custo = Integer.parseInt(custoString);
        } catch (NumberFormatException e) {
            JOptionPane.showMessageDialog(null, "Invalid value.", "Error", JOptionPane.ERROR_MESSAGE);
            System.err.println(e);
            return;
        }
        try {
            Edge a = new Edge(rotulo, custo);
            adjacency[origem][destino] = a;
            adjacency[destino][origem] = a;
        } catch (Exception e) {
            JOptionPane.showMessageDialog(null, "Inexistent ID.", "Error", JOptionPane.ERROR_MESSAGE);
            System.err.println(e);
        }
        drawEdgesLabels();
        redraw = true;
        repaint();
    }

    protected void removeEdge(int origem, int destino) {
        try {
            adjacency[origem][destino] = new Edge("NULL", -1);
            adjacency[destino][origem] = new Edge("NULL", -1);
        } catch (Exception e) {
            JOptionPane.showMessageDialog(null, "Inexistent ID.", "Error", JOptionPane.ERROR_MESSAGE);
            System.err.println(e);
        }
        drawEdgesLabels();
        redraw = true;
        repaint();
    }
    
    
    /**
     * The button that exits the program.
     * @param evt The mouse click event.
     */
    private void subItemFileExitActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_subItemFileExitActionPerformed
        System.exit(0);
    }//GEN-LAST:event_subItemFileExitActionPerformed

    /**
     * The button that calls DFS.
     * @param evt The mouse click event.
     */
    private void subItemSearchDepthFirstActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_subItemSearchDepthFirstActionPerformed
        int node;
        String nodeString = JOptionPane.showInputDialog(graphPanel,
                "Initial node", null);
        try {
            node = Integer.parseInt(nodeString);
        } catch (NumberFormatException e) {
            JOptionPane.showMessageDialog(null, "Invalid value.", "Error", JOptionPane.ERROR_MESSAGE);
            System.err.println(e);
            return;
        }
        depthFirstSearch(node);
    }//GEN-LAST:event_subItemSearchDepthFirstActionPerformed

    /**
     * The button that calls a open file dialog.
     * @param evt The mouse click event.
     */
    private void subItemFileOpenActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_subItemFileOpenActionPerformed
        openFile();
    }//GEN-LAST:event_subItemFileOpenActionPerformed

    /**
     * The button that saves the opened file.
     * @param evt The mouse click event.
     */
    private void subItemFileSaveActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_subItemFileSaveActionPerformed
        saveFile();
    }//GEN-LAST:event_subItemFileSaveActionPerformed

    /**
     * The button that calls Goodman's algorithm.
     * @param evt The mouse click event.
     */
    private void subItemAlgorithmsGoodmanActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_subItemAlgorithmsGoodmanActionPerformed
        goodman(true);
    }//GEN-LAST:event_subItemAlgorithmsGoodmanActionPerformed

    /**
     * The button that invokes a new vertex insertion into a (X,Y) coordinate.
     * @param evt The mouse click event.
     */
    private void subItemEditInsertVertexActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_subItemEditInsertVertexActionPerformed
        int x, y;
        String xString = JOptionPane.showInputDialog(graphPanel,
                "X Coordinate", null);
        try {
            x = Integer.parseInt(xString);
        } catch (NumberFormatException e) {
            JOptionPane.showMessageDialog(null, "Invalid value.", "Error", JOptionPane.ERROR_MESSAGE);
            System.err.println(e);
            return;
        }
        String yString = JOptionPane.showInputDialog(
                graphPanel,
                "Y Coordinate",
                null
        );
        try {
            y = Integer.parseInt(yString);
        } catch (NumberFormatException e) {
            JOptionPane.showMessageDialog(null, "Invalid value.", "Error", JOptionPane.ERROR_MESSAGE);
            System.err.println(e);
            return;
        }
        insertVertex(x, y);
    }//GEN-LAST:event_subItemEditInsertVertexActionPerformed
    
    /**
     * The button that initializes a new file.
     * @param evt The mouse click event.
     */
    private void subItemFileNewActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_subItemFileNewActionPerformed
        reset();
    }//GEN-LAST:event_subItemFileNewActionPerformed
    
    /**
     * The button that calls BFS.
     * @param evt The mouse click event.
     */
    private void subItemSearchBreadthFirstActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_subItemSearchBreadthFirstActionPerformed
        int node;
        String nodeString = JOptionPane.showInputDialog(graphPanel,
                "Initial node", null);
        try {
            node = Integer.parseInt(nodeString);
        } catch (NumberFormatException e) {
            JOptionPane.showMessageDialog(null, "Invalid value.", "Error", JOptionPane.ERROR_MESSAGE);
            System.err.println(e);
            return;
        }
        breadthFirstSearch(node);
    }//GEN-LAST:event_subItemSearchBreadthFirstActionPerformed

    /**
     * The button that insert an edge between two vertices.
     * @param evt The mouse click event.
     */
    private void subItemEditInsertEdgeActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_subItemEditInsertEdgeActionPerformed
        int from, to;
        String fromString = JOptionPane.showInputDialog(graphPanel,
                "Origin ID", null);
        try {
            from = Integer.parseInt(fromString);
        } catch (NumberFormatException e) {
            JOptionPane.showMessageDialog(null, "Invalid value.", "Error", JOptionPane.ERROR_MESSAGE);
            System.err.println(e);
            return;
        }
        String toString = JOptionPane.showInputDialog(
                graphPanel,
                "Destinty ID",
                null
        );
        try {
            to = Integer.parseInt(toString);
        } catch (NumberFormatException e) {
            JOptionPane.showMessageDialog(null, "Invalid value.", "Error", JOptionPane.ERROR_MESSAGE);
            System.err.println(e);
            return;
        }
        insertEdge(from, to);
    }//GEN-LAST:event_subItemEditInsertEdgeActionPerformed

    /**
     * The button that remove a given edge.
     * @param evt The mouse click event.
     */
    private void subItemEditRemoveEdgeActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_subItemEditRemoveEdgeActionPerformed
        int from, to;
        String fromString = JOptionPane.showInputDialog(
                graphPanel,
                "Origin ID",
                null
        );
        try {
            from = Integer.parseInt(fromString);
        } catch (NumberFormatException e) {
            JOptionPane.showMessageDialog(null, "Invalid value.", "Error", JOptionPane.ERROR_MESSAGE);
            System.err.println(e);
            return;
        }
        String toString = JOptionPane.showInputDialog(
                graphPanel,
                "Destiny ID",
                null
        );
        try {
            to = Integer.parseInt(toString);
        } catch (NumberFormatException e) {
            JOptionPane.showMessageDialog(null, "Invalid value.", "Error", JOptionPane.ERROR_MESSAGE);
            System.err.println(e);
            return;
        }
        removeEdge(from, to);
    }//GEN-LAST:event_subItemEditRemoveEdgeActionPerformed

    /**
     * The button that remove a given vertex.
     * @param evt The mouse click event.
     */
    private void subItemEditRemoveVertexActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_subItemEditRemoveVertexActionPerformed
        int id;
        String idString = JOptionPane.showInputDialog(
                graphPanel,
                "ID",
                null
        );
        try {
            id = Integer.parseInt(idString);
        } catch (NumberFormatException e) {
            JOptionPane.showMessageDialog(null, "Invalid value.", "Error", JOptionPane.ERROR_MESSAGE);
            System.err.println(e);
            return;
        }
        if (id < 0 || id >= nVertex) {
            JOptionPane.showMessageDialog(null, "Inexistent ID.", "Error", JOptionPane.ERROR_MESSAGE);
            return;
        }
        removeVertex(id);
    }//GEN-LAST:event_subItemEditRemoveVertexActionPerformed
    
    /**
     * The button that invokes Fleury's algorithm.
     * @param evt The mouse click event.
     */
    private void subItemAlgorithmsFleuryActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_subItemAlgorithmsFleuryActionPerformed
        if (isEulerian()) {
            eulerianPath(adjacency);
        } else {
            JOptionPane.showMessageDialog(null, "Cannot perform eulerian path because the graph isn't eulerian.", "Error", JOptionPane.ERROR_MESSAGE);
        }
    }//GEN-LAST:event_subItemAlgorithmsFleuryActionPerformed

    /**
     * The button that invokes Djikstra's algorithm.
     * @param evt The mouse click event.
     */
    private void subItemAlgorithmsDijkstraActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_subItemAlgorithmsDijkstraActionPerformed
        int node;
        String idString = JOptionPane.showInputDialog(
                graphPanel,
                "Inform the origin node ID.",
                null
        );
        try {
            node = Integer.parseInt(idString);
        } catch (NumberFormatException e) {
            JOptionPane.showMessageDialog(null, "Invalid value.", "Error", JOptionPane.ERROR_MESSAGE);
            System.err.println(e);
            return;
        }
        if (node < 0 || node >= nVertex) {
            JOptionPane.showMessageDialog(null, "Inexistent ID.", "Error", JOptionPane.ERROR_MESSAGE);
            return;
        }
        dijkstra(node);
    }//GEN-LAST:event_subItemAlgorithmsDijkstraActionPerformed

    /**
     * @param args the command line arguments
     */
    public static void main(String args[]) {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html 
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException ex) {
            java.util.logging.Logger.getLogger(VisualizadorGrafo.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (InstantiationException ex) {
            java.util.logging.Logger.getLogger(VisualizadorGrafo.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (IllegalAccessException ex) {
            java.util.logging.Logger.getLogger(VisualizadorGrafo.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        } catch (javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(VisualizadorGrafo.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        /* Create and display the form */
        java.awt.EventQueue.invokeLater(new Runnable() {
            public void run() {
                new VisualizadorGrafo().setVisible(true);
            }
        });
    }

    /**
     * Some really big value. Also known as Big M.
     */
    private final double bigM = Double.POSITIVE_INFINITY;

    /**
     * Location of the opened file.
     */
    private String fileLocation;

    /**
     * Vertices array.
     */
    private Vertex[] vertex;

    /**
     * Edges array.
     */
    private Edge[][] adjacency;

    /**
     * Vertices count.
     */
    private int nVertex;

    /**
     * Flag indicating if the graph should be redrawed.
     */
    private boolean redraw = false;

    /**
     * Connected components count.
     */
    private int connectedComponents = 0;

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JPanel graphPanel;
    private javax.swing.JMenu itemAlgorithms;
    private javax.swing.JMenu itemEdit;
    private javax.swing.JMenu itemFile;
    private javax.swing.JMenu itemSearch;
    private javax.swing.JLabel lblConnectedComponents;
    private javax.swing.JLabel lblEulerian;
    private javax.swing.JMenuBar mainMenu;
    private javax.swing.JFileChooser selectOpenFile;
    private javax.swing.JFileChooser selectSaveFile;
    private javax.swing.JMenuItem subItemAlgorithmsDijkstra;
    private javax.swing.JMenuItem subItemAlgorithmsFleury;
    private javax.swing.JMenuItem subItemAlgorithmsGoodman;
    private javax.swing.JMenuItem subItemEditInsertEdge;
    private javax.swing.JMenuItem subItemEditInsertVertex;
    private javax.swing.JMenuItem subItemEditRemoveEdge;
    private javax.swing.JMenuItem subItemEditRemoveVertex;
    private javax.swing.JMenuItem subItemFileExit;
    private javax.swing.JMenuItem subItemFileNew;
    private javax.swing.JMenuItem subItemFileOpen;
    private javax.swing.JMenuItem subItemFileSave;
    private javax.swing.JMenuItem subItemSearchBreadthFirst;
    private javax.swing.JMenuItem subItemSearchDepthFirst;
    // End of variables declaration//GEN-END:variables
}
